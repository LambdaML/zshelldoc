# vim:ft=zsh
# This file is double-licensed under GPLv3 and MIT (see LICENSE file)

### Options ###

local OPT_HELP OPT_VERBOSE OPT_QUIET OPT_NOANSI
local -A opthash
zparseopts -E -D -A opthash h -help v -verbose q -quiet n -noansi || { echo "Improper options given, see help (-h/--help)"; return 1; }

(( ${+opthash[-h]} + ${+opthash[--help]} ))     && OPT_HELP="-h"
(( ${+opthash[-v]} + ${+opthash[--verbose]} ))  && OPT_VERBOSE="-v"
(( ${+opthash[-q]} + ${+opthash[--quiet]} ))    && OPT_QUIET="-q"
(( ${+opthash[-n]} + ${+opthash[--noansi]} ))   && OPT_NOANSI="-n"

[[ -n "$OPT_NOANSI" ]] && { colors=(); fg=(); bg=(); fg_bold=(); bg_bold=(); reset_color=""; }

[[ -z "$OPT_QUIET" ]] && print "$fg[cyan]zsd-detect starting for file \`$fg_bold[yellow]$1$fg_no_bold[cyan]' (2nd pass)$reset_color"

if [[ -n "$OPT_HELP" ]]; then
    usage
    return 0
fi

if [[ "$#" -le 0 || "$*" = [[:space:]]## ]]; then
    print "Argument needed, see help (-h/--help)"
    return 1
fi

if [[ ! -f "$1" ]]; then
    [[ -z "$OPT_QUIET" || -n "$OPT_VERBOSE" ]] && print "$fg[magenta]File \`$1' doesn't exist, skipping it (see help, with -h/--help option)$reset_color"
    return 1
fi

if [[ ! -r "$1" ]]; then
    [[ -z "$OPT_QUIET" || -n "$OPT_VERBOSE" ]] && print "$fg[magenta]File \`$1' is unreadable, skipping it (see help, with -h/--help option)$reset_color"
    return 1
fi

### Code ###

local name="$1"
local doc="$(<$name)" token prev_token="" spaces prev_spaces="" next_token next_spaces

# Function and preamble extraction
local preamble="" fun_name=""
local -A funs
integer next_fun=0 cur_fun=0 prev_fun=0
integer depth=0 prev_depth=0 fun_depth=-1 anon_depth=-1 descentff=0 descentfa=0

# Function-comment extraction
local cproposal=""
local -A cfuns

# Call-tree extraction
integer at_command=1
local -A call_tree rev_call_tree
local -a known_functions
known_functions=( zsdoc/data/functions/**/*(N) )
known_functions=( ${known_functions[@]#zsdoc/data/functions/} )

line_count()
{
    local -a list
    list=( "${(@f)1}" )
    local count=${#list}
    [[ "$1" = *$'\n' ]] && (( -- count ))
    print -r -- "${(l:3:: :)count}"
}

conv_ldrawing()
{
    local IFSBKP="$IFS"
    IFS=""
    while read -r line; do
        line="${line//├──/|--}"
        line="${line//└──/\`--}"
        line="${line//│/|}"
        echo "$line"
    done
    IFS="$IFSBKP"
}

zsd-process-buffer "$doc" 1
integer i size="${#ZSD_PB_WORDS}"

for (( i=1; i<=size; ++ i )); do
    token="${ZSD_PB_WORDS[i]}"
    spaces="${ZSD_PB_SPACES[i]}"
    next_token="${ZSD_PB_WORDS[i+1]}"
    next_spaces="${ZSD_PB_SPACES[i+1]}"
    cur_fun=0 prev_fun=0 descentff=0 descentfa=0

    (( next_fun )) && { next_fun=0 cur_fun=1 prev_fun=0 anon_depth=-1 }

    # Detect function call
    if [[ "$spaces" = *$'\n'* || -z "$prev_token" ]]; then
        at_command=1
    fi
    if (( at_command )); then
        at_command=0

        local tokenEx="*${(q)token}"
        local found="${known_functions[(r)$tokenEx]}"
        if [[ -z "$fun_name" ]]; then
            local needle="${(q)name}/zsd_script_body"
        else
            local needle="${(q)name}/${(q)fun_name}"
        fi

        if [[ "$cur_fun" -eq 0 && "$next_token" != "()" && -n "$found" ]]; then
            if [[ -z "$fun_name" ]]; then
                [[ "${call_tree[${(q)name}/zsd_script_body]}" != *[[:blank:]]"${(q)found}"[[:blank:]]* ]] && {
                    call_tree[${(q)name}/zsd_script_body]+=" ${(q)found} "
                }
                [[ "${rev_call_tree[${(q)found}]}" != *[[:blank:]]"$needle"[[:blank:]]* ]] && {
                    rev_call_tree[${(q)found}]+=" ${(q)name}/zsd_script_body "
                }
            else
                [[ "${call_tree[${(q)name}/${(q)fun_name}]}" != *[[:blank:]]"${(q)found}"[[:blank:]]* ]] && {
                    call_tree[${(q)name}/${(q)fun_name}]+=" ${(q)found} "
                }
                [[ ${rev_call_tree[${(q)found}]} != *[[:blank:]]"$needle"[[:blank:]]* ]] && {
                    rev_call_tree[${(q)found}]+=" ${(q)name}/${(q)fun_name} "
                }
            fi
        fi

        if [[ "$token" = [[:space:]]#\#* ]]; then
            if [[ "$spaces" = [[:space:]]#$'\n'[[:space:]]#$'\n'* ]]; then
                cproposal="$token$next_spaces"
            else
                cproposal+="$token$next_spaces"
            fi
        else
            if [[ "$token" != "function" && ( "$next_token" != "()" || "$next_spaces" = *$'\n'* ) ]]; then
                cproposal=""
            fi
        fi
    fi

    # Explicit future function
    if [[ "$token" = "function" ]]; then
        next_fun=1 cur_fun=0 prev_fun=0 anon_depth=-1
    # Detect function if not already in function
    elif [[ "$token" = "()" && ( "$fun_depth" -lt 0 ) && ( $anon_depth -lt 0 ) ]]; then
        if [[ "$spaces" = *$'\n'* || -z "$prev_token" ]]; then
            next_fun=0 cur_fun=0 prev_fun=0 anon_depth=$depth
        else
            next_fun=0 cur_fun=0 prev_fun=1 anon_depth=-1
        fi
    elif [[ "$token" = "{" ]]; then
        (( ++ depth ))
    elif [[ "$token" = "}" ]]; then
        (( -- depth ))
    fi

    if (( cur_fun )); then
        fun_name="$token"
        fun_depth="$depth"
        cfuns[$fun_name]="${cproposal%%$'\n'##}"
    elif (( prev_fun )); then
        fun_name="$prev_token"
        fun_depth="$depth"
        cfuns[$fun_name]="${cproposal%%$'\n'##}"
    fi

    # Ascent to function - skip '{'
    if (( fun_depth >= 0 && depth == (fun_depth + 1) )) && [[ "$token" = "{" ]]; then
        :
    # In-function
    elif (( fun_depth >= 0 && depth > fun_depth )); then
        if [[ "$token" != [[:space:]]#\#* ]]; then
            funs[$fun_name]+="${spaces}${token}"
        fi
    # Descent from function - skip '}'
    elif (( fun_depth >= 0 && depth == fun_depth && prev_depth == fun_depth + 1 )); then
        descentff=1
    # Descent from anon
    elif (( anon_depth >= 0 && depth == anon_depth && prev_depth == anon_depth + 1 )); then
        descentfa=1
    fi

    # Anon function in top-level
    if (( anon_depth >= 0 && fun_depth < 0 )); then
        [[ "$token" != [[:space:]]#\#* ]] && preamble+="${spaces}${token}"
    fi

    # Late disable of (anon)
    if (( descentfa )); then
        anon_depth=-1
    elif (( descentff )); then
        fun_name=""
        fun_depth=-1
    # No-function printing
    elif (( next_fun == 0 && cur_fun == 0 && prev_fun == 0 && anon_depth < 0 && fun_depth < 0 )); then
        if [[ "$next_token" != "()" || "$next_spaces" = *$'\n'* ]]; then
            [[ "$token" != [[:space:]]#\#* ]] && preamble+="${spaces}${token}"
        fi
    fi

    prev_depth="$depth"
    prev_token="$token"
    prev_spaces="$spaces"
done

command mkdir -p zsdoc/data
command rm -f zsdoc/data/call_tree.zsd
command rm -f zsdoc/data/rev_call_tree.zsd

for fun_name in "${(ko@)call_tree}"; do
    echo "$fun_name:${call_tree[$fun_name]% }" >>| zsdoc/data/call_tree.zsd
done

[[ -z "$OPT_QUIET" ]] && print "$fg[yellow]Written call tree$reset_color (${#call_tree} callers)"

for fun_name in "${(ko@)rev_call_tree}"; do
    echo "$fun_name: ${rev_call_tree[$fun_name]% }" >>| zsdoc/data/rev_call_tree.zsd
done

[[ -z "$OPT_QUIET" ]] && print "$fg[yellow]Written reverse call tree$reset_color (${#rev_call_tree} called functions)"

command mkdir -p "zsdoc/data/descriptions/$name"

for fun_name in "${(ko@)cfuns}"; do
    [[ -z "${cfuns[$fun_name]}" ]] && continue
    [[ -z "$OPT_QUIET" ]] && print "Extracted `line_count ${cfuns[$fun_name]}`-line comment of \`$fg[green]${fun_name}$reset_color'..."
    echo "${cfuns[$fun_name]}" >| "zsdoc/data/descriptions/$name/$fun_name"
done

command mkdir -p "zsdoc/data/trees/$name"
local PWDBKP="$PWD"
cd "zsdoc/data/trees/$name"
integer count=0
for fun_name in "${(ko@)call_tree}"; do
    (( ++ count ))
    process_node "$fun_name"
    local fun="${fun_name##*/}"
    if [[ "$fun" = "zsd_script_body" ]]; then
        tree --charset="utf-8" "$name" | conv_ldrawing > "${name}.tree"
    else
        tree --charset="utf-8" "$fun" | conv_ldrawing > "${fun}.tree"
    fi
done

cd "$PWDBKP"

[[ -z "$OPT_QUIET" ]] && print "$fg[yellow]Generated $count trees$reset_color"
